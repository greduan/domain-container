<!--
vim: ts=2:sw=2:expandtab
-->

# Krypton ModelsWrapper Spec

## Index

- [Intro](#intro)
- [Feature summary](#feature-summary)
- [Background](#background)
- [Constraints](#constraints)
- [Assumptions](#assumptions)
- [Blackbox](#blackbox)
- [Functional spec](#functional-spec)
- [Technical spec](#technical-spec)
- [Examples](#examples)
  - [Multi-site](#multi-site)

## Intro

This document defines a standalone (not related to any particular project)
interface for Krypton models which offers a way to isolate the same models
according to different environments, stuff like multi-site setups where the data
structures are the same but the data is different since there are different DBs.

## Feature summary

- Allows you to give the same set of models different Knex instances
  (especially useful in multi-site setups).
- Allows you to pass an arbitrary amount of properties to each model before any
  actions are carried out (except when querying).

## Background

There is a need to have a container for the models that has a hold of their
Knex instance, so that the Knex instance doesn't have to be passed around every
time you want to do something with a model.

And it can also hold an unspecified amount of things that the models may need in
the particular project, these are dynamic and specified when instantiating the
wrapper.

As long as one has some sort of way to uniquely identify the different
ModelsWrappers, e.g. a subdomain, ModelsWrapper is useful as a way to separate
database environments, by providing a different Knex instance to each
ModelsWrapper, and that is the main purpose they were designed for.

## Constraints

- Has to use Neon DSL.
- Has to interface with Krypton ORM seamlessly.
- Has to provide a mechanism to pass in (once) an unspecified amount of
  parameters to each model instance, which the instance may need to do its
  thing.

## Assumptions

- The models that it handles are models generated by the Krypton ORM and they
  have not been given a Knex instace, i.e. they are dynamic.
- The environment it is used in will do the instantiation with its own logic
  that applies to that environment.
- The environment knows how to store and access different ModelsWrapper
  instances.
- The environment will implement some sort of caching mechanism, as it is not
  cheap to be creating ModelsWrapper instances.

## Blackbox

Here we'll just do some basic blackbox examples to give an idea of behaviour.

---

Let's quickly see what an instance looks like.

Input:

``` javascript
var wrapper = new Wrapper({
  knex: knex, // we got this from somewhere
  models: {
    User: User, // we got this from somewhere
  },
  customProps: {
    mailers: mailers, // we got this from somewhere
  },
});
```

Output:

``` javascript
// this is an instance of ModelsWrapper
ModelsWrapper({
  _knex: ..., // same as provided above
  _models: ..., // same as provided above
  _customProps: ..., // same as provided above, empty object default though
  presenters: {}, // empty object default
  
  query: function () {...},
  create: function () {...},
  update: function () {...},
  destroy: function () {...},
});
```

---

``` javascript
var wrapper = new ModelsWrapper({...});

wrapper.query('User'); // => User QueryBuilder
```

---

``` javascript
var wrapper = new ModelsWrapper({...});

wrapper
  .create('User', {
    email: 'example@gmail.com',
    password: 'yay',
  })
  .then(function (user) {
    // user is the model of the record that was created in the DB
  });

// In the DB there is a new record:
// {
//   id: 1,
//   email: 'example@gmail.com',
//   password: 'yay',
// }
//
// An email is sent from a mailer to example@gmail.com with a token
```

---

``` javascript
var wrapper = new ModelsWrapper({...});

var model = new User({ id: 1 });

wrapper
  .update(model, {
    password: 'nope',
  })
  .then(function (user) {
    // user is the model of the record that was created in the DB
  });

// In the DB, the record created above is updated to:
// {
//   id: 1,
//   password: 'nope',
//   ...
// }
//
// An email is sent from a mailer to example@gmail.com to inform of password change
```

---

``` javascript
var wrapper = new ModelsWrapper({...});

var model = new User({ id: 1 });

wrapper
  .destroy(model)
  .then(function () {
    // ...
  });

// In the DB, the record created above no longer exists
```

---

To quickly demonstrate the use of several Knex instances:

``` javascript
var wrapper1 = new ModelsWrapper({
  ...
  knex: knex1,
  ...
});

var wrapper2 = new ModelsWrapper({
  ...
  knex: knex2,
  ...
});

wrapper1.query('User')
  .where('id', 1)
  .then(function (result) {
    console.log(result);
    // => {
    //   id: 1,
    //   email: 'first-wrapper@example.com',
    //   ...
    // }
  });

wrapper2.query('User')
  .where('id', 1)
  .then(function (result) {
    console.log(result);
    // => {
    //   id: 1,
    //   email: 'second-wrapper@example.com',
    //   ...
    // }
  });
```

## Functional spec

**NOTICE: Please ignore the Technical spec below for now, the spec is not yet
at a point where that is relevant.  Please only read this Functional spec.
Below the Technical spec there are other things to read though, just FYI.**

The module will provide a Neon class called ModelsWrapper.

This class, at instantiation, will take on Knex instance, an object with
Krypton models, an optional presenters object and an optional customProps
object.

These properties will be saved as instance variables (some with `_` prefix
to indicate they are private).

The ModelsWrapper instance will provide the following instance methods:

- `#query(modelName)` returns a Krypton model QueryBuilder from the model that
  it is being requested.
- `#create(modelName, body)` creates a model instance with the properties of
  `body` and saves the resulting model to the DB.
- `#update(modelInstance, body)` calls `.updateAttributes(body)` on the provided
  model and saves the changes to the DB.
- `#destroy(modelInstance)` calls `.destroy()` on the provided model, destroying
  the record in the DB.

Notes:

- All of the above methods use the Knex instance provided at the ModelsWrapper's
  instantiation for their queries.
- All of the above methods that interact with the DB directly (`#create`,
  `#update` and `#destroy`) pass in the ModelsWrapper instance's
  `this._customProps` properties to the models so that the models may make use
  of them.
- All of the amove methods when not being passed the model (i.e. the `#query` and
  `#create` methods) they grab the model by doing something like
  `this._models[modelName]`.

Observations:

- With the above setup, one could pass an instance that is generated by the
  controller (i.e. the controller does:

  ``` javascript
  var model = new Model({ id: req.query.params }); `

  req.wrapper.destroy(model).then(...);
  ```

  And that would properly destroy the model, since before being destroyed the
  model instance is being passed in the `customProps`, so it can properly make
  use of those variables.

## Technical spec

**NOTICE: Please ignore this for now, the spec is not yet at a point where this
is relevant.  Please only read the Functional spec above.  Below this Technical
spec there are other things to read though, just FYI.**

### Class `ModelsWrapper(<Object> initProps)`

`<Object> initProps` available properties:

- `<Knex> knex` a Knex instance which will be used in all the models' queries.
- `<Object> models` an object with all of the models the wrapper will wrap.
  Must be model constructors, not instances.
- `<Object> {Optional} customProps` props that will be handed to every model
  instance that will be used to modify the DB in some way (not query).
- `<Object> {Optional} presenters` presenters for models.

#### Instance variables

These are mostly set by the `<Object> initProps` parameter set and
ModelsWrapper instantiation.

##### `_knex`

Holds the Knex instance that will be provided to every model.

It's set to whatever the `initProps.knex` property was when instantiating the
ModelsWrapper.

##### `_models`

Holds all the models that will be avaialble to the ModelsWrapper.  Must be the
model constructors, not instances.

It's set to whatever the `initProps.models` property was when instantiating the
ModelsWrapper.

##### `_customProps`

Holds the properties that will be passed in to each model whenever it is being
instantiated to modify the DB, i.e. not being used to query.

This could be anything, changes from project to project, but an easy example
would be mailer instances which the models would use, instead of some global
one which isn't configured for the specific models.

It's set to whatever the `initProps.customProps` property was when
instantiating the ModelsWrapper.

##### `presenters`

**NOTICE:** Presenters are currently not used, while how to define them is
defined in this document, they are not in use and thus the rest of the spec will
not define how to make use of them.

Presenters are functions that modify the model they are passed in in order to
make it consumeable by the front end, by removing sensitive data or adding more
data.

The object is made up of properties containing functions, the property name is
the name of the model.  The function would be passed in a model instance which
it would manipulate, the function is expected to return a promise, if the
promise returns a value the model will be replaced by the returned value.

An example `presenters` object would be:

```javascript
presenters: {
  User: function (user) {
    delete user.password;
    delete user.encryptedPassword;
    delete user.token;

    return Promise.resolve();
  },
},
```

#### Instance methods

##### `#init(<Object> initProps)`

This method is run whenever the Class is instantiated, i.e. whenever a new
ModelsWrapper instance is created.

```javascript
prototype: {
  _knex: null,
  _models: null,
  _customProps: {},
  presenters: {},

  init: function (initProps) {
    var that = this;

    that._knex = initProps.knex;
    that._models = initProps.models;

    if (!_.isUndefined(initProps.customProps)) {
      that._customProps = initProps.customProps;
    }

    if (!_.isUndefined(initProps.presenters)) {
      that.presenters = initProps.presenters;
    }
  },
},
```

##### `#query(<String> modelName)`

This method returns a Krypton QueryBuilder for the requested model.  It returns
an error if the model doesn't exist.

Pseudo-code:

```javascript
prototype: {
  query: function (modelName) {
    var that = this;

    var Model = that._models[modelName];

    if (!Model) {
      throw new Error('Model ' + modelName + ' doesn\'t exist in the ModelsWrapper');
    }

    return Model.query(that._knex);
  },
},
```

##### `#create(<String> modelName, <Object> body)`

This method creates a new entry in the DB with the model provided (identified by
`<String> modelName` parameter) and returns the instance of that model that was
saved.  The contents of the new model are contained in the `<Object> body`
parameter.  It returns an error if the model doesn't exist.

Pseudo-code:

```javascript
prototype: {
  create: function (modelName, body) {
    var that = this;

    var Model = that._models[modelName];

    if (!Model) {
      throw new Error('Model ' + modelName + ' doesn\'t exist in the ModelsWrapper');
    }

    var model = new Model(that._customProps);
    model.updateAttributes(body);

    return model.save(that._knex)
      .then(function () {
        return model;
      });
  },
},
```

##### `#update(<Model> model, <Object> body)`

This method receives a pre-existing model and updates it with the parameters
passed in through the `<Object> body` parameter.

Pseudo-code:

```javascript
protoype: {
  update: function (model, body) {
    var that = this;

    model.updateAttributes(body);

    return model.save(that._knex)
      .then(function () {
        return model;
      });
  },
},
```

##### `#delete(<Model> model)`

This method destroys the record in the DB for the provided model (`<Model>
model` parameter).

Pseudo-code:

```javascript
protoype: {
  destroy: function (model) {
    var that = this;

    return model.destroy(that._knex)
      .then(function () {
        return model;
      });
  },
},
```

## Examples

### Multi-site

The use case for which this module was designed goes as follows:

Setup:

- Requests can come in for `foo.domain.com` or `bar.domain.com`, `foo` and
  `bar` subdomains have different databases, however their structures, and thus
  models, are exactly the same.
- There is a `domain-parser` middleware, which sets the `req.subdomainName`
  variable to `foo` or `bar` in this scenario.
- Right after there is a `models-wrapper` middleware, which has logic
  somewhat like the following:

  ```javascript
  // Pseudo-code

  // Outside middleware context:

  var ModelsWrapper = require('models-wrapper');
  var wrappers = {}; // cache

  // Inside middleware context:

  var name = req.subdomainName;

  var newWrapper;

  if (wrappers[name]) {
    req.wrapper = wrappers[name];
  } else {
    // skipping some logic to fetch Knex and models and stuff
    newWrapper = new ModelsWrapper({ ... });
    wrappers[name] = newWrapper; // cache wrapper
    req.wrapper = wrappers[name]; // set request's wrapper
  }

  return next();
  ```

General flow:

- A request comes in for `foo.domain.com`
- `domain-parser` middleware sets `req.subdomainName` to `foo`
- `models-wrapper` middleware finds no cache for a `foo` wrapper, sets
  `req.wrapper` to a new instance of ModelsWrapper
- Controller somewhere down the line does `req.wrapper.query('User')...`

What the above effectively achieves is to have one configuration of models for
`foo` subdomain and another for `bar` subdomain.

#### Mailers

In this multi-site setup one could have the front end views adapt to the
environment contained in the `req` variable if one is clever, often that is the
only choice you have, but a mailer's views do not have access to the `req`
object, since a mailer is standalone, so usually you would have to instantiate a
mailer, with the environment specific vars passed in, and send the email, in the
end you pass the `req` around some more.

But with the ModelsWrapper, you could just pass in a UserMailer instance as one
of the properties in the `customProps` at instantiation, this would mean that
when the models send emails they would have access to the mailers right away
without having to pass it in manually or in a particularly special way.
