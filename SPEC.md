# DomainContainer Spec

## Intro

This document defines an interface for Krypton models which offers a way to
isolate the same models according to different environments.

Especially useful with stuff like multi-site setups where the data structures
are the same but the datas are different because there are several DBs.

## Feature summary

- Allows you to give the same set of models different Knex instances,
  i.e. different DB instances.
- With the above, allows you for these models to be accessed through the same
  interface, regardless of which DB instance the models are using.
- Allows you to pass an arbitrary amount of properties to each model before any
  actions are carried out (except when querying).

## Background

There is a need to have a container for the models and the environment that they
carry around, without having to put it all in the `req` variable of your routing
lib.  I.e. not have to pass around a Knex instance in the `req`, mailer
instances, and many other environment specific vars.

This module solves that environment containment problem.

As long as one has some sort of way to uniquely identify the different
DomainContainer instances, e.g. a subdomain, DomainContainer is useful as a way
to separate database environments.

## Constraints

- Has to use Neon DSL.
- Has to interface with the Krypton ORM.
- Has to provide a mechanism to pass in an unspecified amount of properties to
  each model instance, which the instance may need to do its things.

## Assumptions

- The models that it handles are models generated by the Krypton ORM and they
  have not been assigned a Knex instance with `.knex()`.
- All the used Krypton methods return promises.
- The environment it is used in will do the instantiation with its own logic
  that applies to that environment.
- The environment knows how to store and access different DomainContainer
  instances.
- The environment will implement some sort of caching mechanism, as it is not
  cheap to be creating DomainContainer instances.

## Blackbox

![blackbox image](https://www.lucidchart.com/publicSegments/view/41711772-da29-4522-a9c0-728c4ce242de/image.png)

- `._knex` is a Knex instance passed in at instantiation.
- `._modelExtras` is an object assigned to models before their interactions with
  the DB.
- `._models` is an object containing Krypton model constructors.  The container
  gets its models from here.
- `.props` is an object containing arbitrary, static properties.

- `#query()` is a method that returns a QueryBuilder for the requested model.
- `#create()` is a method that creates the requested model and saves it with the
  provided body.
- `#update()` is a method that updates the provided model with the provided
  body or can just run `.save()` if provided no body.
- `#destroy()` is a method that destroys the provided model.
- `#get()` is a method that returns a model's constructor pre-loaded with some
  container properties.
- `#cleanup()`, destroys the container's Knex instance.

## Functional spec

### `generateContainerModels(models, container)` function

Takes in two objects as its arguments, the `models` object should be composed of
model constructors and `containerInstance` should be the DomainContainer
instance that contains the properties we will attach to models.

What it does is loop through the objects and it generates an identical object in
terms of properties and its contents, except the models it puts into the
resulting object have some properties pre-loaded, namely:

```js
{
  _container: container,
  _modelExtras: container._modelExtras,

  prototype: {
    _container: container,
    _modelExtras: container._modelExtras,
  },
}
```

And of course the properties the model sets by itself are not touched, unless
they're named the same.  This allows the models inner routines to still make use
of the container without having to jump through hoops to do so.

Also setting it in the constructor and prototype allows the models to always use
the constructor (for consistency) and outer stuff that wants to use the
container can use the prototype stuff.

### `DomainContainer` class

A Class which at initialization takes one argument which contains the options
and properties the instance needs to function, and the optional ones as well.

It would contain the following props:

```js
{
  knex: Knex, // required
  models: {}, // required
  modelExtras: {}, // optional
  props: {}, // optional
}
```

- `knex` is the Knex instance that the container would use for all of its
  requests to the DB.
- `models` are the models that the user will have access to use for the
  DomainContainer methods.
- `modelExtras` are just things that would get passed to the models before they
  interact with the DB in case they want to do any actions there.
- `props` are just static properties for or about the container.

#### Instantiation

At instantiation, with the passed in `initProps` property it would assign the
following properties to the DomainContainer instance:

```js
{
  _knex: initProps.knex,
  _models: generateContainerModels(initProps.models), // functionality described above
  _modelExtras: initProps.modelExtras || {},
  props: initProps.props || {},
}
```

#### `#query(modelName)`

Creates a Knex QueryBuilder based for the `modelName` that is passed in, it
grabs the model from `this._models`.

It then returns the result of calling `.query(this._knex)` on that model.

Throws error if it can't find the `modelName` in `this._models`.

#### `#create(modelName, body)`

Creates a model (`this._models[modelName]`) with the given body, body should be
an object otherwise the model will have problems.

Calls `.save()` on the new model instance and returns a Promise with the
resulting created model.

As a work around for a problem that Checkit has (see
[#73](https://github.com/tgriesser/checkit/issues/73)) we explicitly set the new
model's `._modelExtras` and `._container` to be what they should be, so they
don't get lost while getting cloned by Checkit.

Throws error if it can't find the `modelName` in `this._models`.

#### `#update(model, body)`

Calls `.updateAttributes(body)` on the `model` and then `.save(this._knex)` and
returns the generated Promise.

Unless `body` is undefined, in which case it'll just do `.save(this._knex)`.

Just like `#create`, as a work around for a problem that Checkit has (see
[#73](https://github.com/tgriesser/checkit/issues/73)) we explicitly set the new
model's `._modelExtras` and `._container` to be what they should be, so they
don't get lost while getting cloned by Checkit.

#### `#destroy(model)`

Simply calls `.destroy(this._knex)` on the given `model` and returns the
generated Promise.

#### `#get(modelName)`

Returns `this._models[modelName]`

#### `#cleanup()`

Calls `this._knex.destroy()` and returns the generated Promise.

Throws error if it can't find the `modelName` in `this._models`.

## Technical spec

### Function `generateContainerModels(<Object> models, <DomainContainer> container)`

Parameters:

- `models`, Required, Object, object made up of the model constructors.
- `container`, Required, DomainContainer instance, instance containing the
  properties that will be assigned to the newly generated models.

Returns:

An Object made up of the same same keys as the passed-in `models`, with the same
models, except they've been pre-loaded with some properties:

```js
{
  _container,
  _modelExtras,

  prototype: {
    _container,
    _modelExtras,
  },
}
```

Typical use case:

```js
// M = global project's models namespace

// inside container instantiation
this._models = generateContainerModels(M, this);
```

Pseudo-code:

```
Set result to be equal to an empty Object

Call Object.keys() with arguments:
  1. `models`
Call on that result .foreach() with arguments:
  1. function with arguments `key`
    Set Model to be equal to `models[key]`

    Set TmpModel to be equal to:
      Call Class() with arguments:
        1. Empty Object
        2. `key`
      Call on that result .inherits() with arguments:
        1. `Model`
      Invoke resulting function with arguments:
        1. Object: {
          _modelExtras: `container._modelExtras`
          _container: `container`

          prototype: Object: {
            _modelExtras: `container._modelExtras`
            _container: `container`
          }
        }

    Call TmpModel.knex() with arguments:
      1. `container._knex`

    Set `result[key]` to be equal to `TmpModel`

Return `result`
```

### Class `DomainContainer(<Object> initProps)`

#### Initialization

Parameters:

- `initProps`, Required, Object:
  - `knex`, Required, Knex instance, Knex instance which will be used in the
    queries.
  - `models`, Required, Object, an object with all of the models constructors
    the container will wrap.
  - `modelExtras`, Optional, Object, object assigned to models before their
  interactions with the DB.
  - `props`, Optional, Object, metadata for the container.

Typical use case:

```js
var container = new DomainContainer({
  props: {
    installationName: req.installationName,
  },
  knex: knexInst,
  models: M,
  modelExtras: {
    mailers: {
      user: new UserMailer(),
    },
  },
});
```

Pseudo-code:

```
If `initProps.knex` is undefined
  Throw new Error 'initProps.knex property is required'
Else
  Set this._knex to be equal to `initProps.knex`

Set this._modelExtras to be equal to `initProps.modelExtras` Or an empty Object if undefined
Set this._props to be equal to `initProps.props` Or an empty Object if undefined

If `initProps.models` is undefined or not an Object
  Throw new Error 'initProps.models property is required and should be an object'
Else
  Set this._knex to be equal to:
    Call generateContainerModels() with arguments:
      1. `initProps.models`
      1. `this`
```

#### `#query(<String> modelName)`

Parameters:

- `modelName`, Required, String, the name of the model for which to get a
  Krypton QueryBuilder.

Returns:

Krypton QueryBuilder for the requested `modelName`.

If `this._models[modelName]` is undefined it returns a rejected Promise with
`Error('Model ${modelName} doesn\'t exist in the DomainContainer')` as the
reason.

Typical use case:

```js
container.query('User')
  .where('id', req.params.id)
  .andWhere('name', '!=', 'John')
  .then(...)
  .catch(...);
```

Pseudo-code:

```
Set Model to be equal to `this._models[modelName]`

If Model is equal to undefined
  Return rejected Promise with Error 'Model ${modelName} doesn\'t exist in the DomainContainer'
Else
  Return Call to Model.query() with arguments:
    1. this._knex
```

#### `#create(<String> modelName, <Object> body)`

Parameters:

- `modelName`, Required, String, the name of the model which to create.
- `body`, Required, Object, the body for the new model.

Returns:

A Promise which has the newly created model instance.

If `this._models[modelName]` is undefined it returns a rejected Promise with
`Error('Model ${modelName} doesn\'t exist in the DomainContainer')` as the
reason.

Typical use case:

```js
container.create('User', { name: 'Jon' })
  .then(...)
  .catch(...);
```

Pseudo-code:

```
Set Model to be equal to `this._models[modelName]`

If Model is equal to undefined
  Return rejected Promise with Error 'Model ${modelName} doesn\'t exist in the DomainContainer'
Else
  Set model be equal to:
    Call to `new Model` with arguments:
      1. `body`

  Set model._modelExtras to point to `this._modelExtras`
  Set model._container to point to `this`

  Return:
    Call model.save()
    Chain .then() with arguments:
      1. function with no arguments
        Return `model`
```

#### `#update(<Model> model, <Object> {Optional} body)`

Parameters:

- `model`, Required, model instance, model to update in the DB.
- `body`, Optional, Object, body to apply to model instance.

Returns:

Result of `model.save(this._knex)`.

Typical use cases:

```js
var model = new M.Model({
  id: 1,
  name: 'Josh', // old name 'Jon'
});

container.update(model)
  .then(...)
  .catch(...);
```

```js
var model = new M.Model({
  id: 1,
  name: 'Jon',
});

container
  .update(model, {
    name: 'Josh',
  })
  .then(...)
  .catch(...);
```

Pseudo-code:

```
If `body` is not undefined
  Call model.updateAttributes() with arguments:
    1. `body`
Else
  Set model._modelExtras to point to `this._modelExtras`
  Set model._container to point to `this`

  Return:
    Call model.save() with arguments:
      1. `this._knex`
    Chain .then() with arguments:
      1. function with no arguments
        Return `model`
```

#### `#destroy(<Model> model)`

Parameters:

- `model`, Required, model instance, model to delete from DB.

Returns:

Typical use case:

```js
var model = new M.Model({ id: 1 });

container.destroy(model)
  .then(...)
  .catch(...);
```

Pseudo-code:

```
Set model._modelExtras to point to `this._modelExtras`
Set model._container to point to `this`

Return:
  Call model.destroy() with arguments:
    1. `this._knex`
  Chain .then() with arguments:
    1. function with no arguments
      Return `model`
```

#### `#get(<String> modelName)`

Parameters:

- `modelName`, Required, String, name of model to fetch the constructor for.

Returns:

The requested model constructor.

If `this._models[modelName]` is undefined it returns a rejected Promise with
`Error('Model ${modelName} doesn\'t exist in the DomainContainer')` as the
reason.

Typical use case:

```js
var Model = container.get('Model');

var model = new Model(...);

...
```

Pseudo-code:

```
Set Model to be equal to `this._models[modelName]`

If Model is equal to undefined
  Return rejected Promise with Error 'Model ${modelName} doesn\'t exist in the DomainContainer'
Else
  Return `Model`
```

#### `#cleanup()`

Parameters: none

Returns:

Typical use case:

```js
container.cleanup()
  .then(...)
  .catch(...);
```

Pseudo-code:

```
Set that to equal `this`

Return new Promise with arguments:
  1. function with arg `resolve`
    Call that._knex.destroy() with arguments:
      1. function
        Call resolve() with no arguments
```

## Code snippets

Let's quickly see what an instance looks like.

Input:

```javascript
var container = new DomainContainer({
  knex: knex, // we got this from somewhere
  models: {
    User: User, // we got this from somewhere
  },
  modelExtras: {
    mailers: mailers, // we got this from somewhere
  },
});
```

Output:

```javascript
// this is an instance of DomainContainer
DomainContainer({
  _knex: ..., // same as provided above
  _models: ..., // same as provided above
  _modelExtras: ..., // same as provided above, empty object default though
  props: {}, // empty object default

  query: function () {...},
  create: function () {...},
  update: function () {...},
  destroy: function () {...},
  get: function () {...},
});
```

---

To quickly demonstrate the use of several Knex instances:

```javascript
var container1 = new DomainContainer({
  ...
  knex: knex1,
  ...
});

var container2 = new DomainContainer({
  ...
  knex: knex2,
  ...
});

container1.query('User')
  .where('id', 1)
  .then(function (result) {
    console.log(result);
    // => {
    //   id: 1,
    //   email: 'first-container@example.com',
    //   ...
    // }
  });

container2.query('User')
  .where('id', 1)
  .then(function (result) {
    console.log(result);
    // => {
    //   id: 1,
    //   email: 'second-container@example.com',
    //   ...
    // }
  });
```

---

Model making use of `._container`.

```javascript
var Model = Class({}, 'Model').inherits(Krypton.Model)({
  prototype: {
    init: function (config) {
      var that = this;

      that.on('beforeCreate', function (next) {
        that.constructor._container
          .create('Model2', { some: 'value' })
          .then(function (model) {
            return next();
          })
          .catch(next);
      });
    },
  },
});
```

## Examples

### Multi-site

The use case for which this module was designed goes as follows:

Setup:

- Requests can come in for `foo.domain.com` or `bar.domain.com`, `foo` and
  `bar` subdomains have different databases, however their structures, and thus
  models, are exactly the same.
- There is a `domain-parser` middleware, which sets the `req.subdomainName`
  variable to `foo` or `bar` in this scenario.
- Right after there is a `domain-container` middleware, which has logic
  somewhat like the following:

  ```text
  // Pseudo-code

  // Outside middleware context:

  let containers be an empty object

  // Inside middleware context:
  function (req, res, next)
    let name be req.subdomainName;

    var newContainer;

    if you can find current container (name) in containers
      let req.container be what we found
    else
      create new container
      add new container to containers
      let req.container be to the new container

    call next
  ```

General flow:

- A request comes in for `foo.domain.com`
- `domain-parser` middleware sets `req.subdomainName` to `foo`
- `domain-container` middleware finds no cache for a `foo` container, sets
  `req.container` to a new instance of DomainContainer
- Controller somewhere down the line does `req.container.query('User')...`

What the above effectively achieves is to have one configuration of models for
`foo` subdomain and another for `bar` subdomain.

### `modelExtras` use cases

#### Mailers

Let's say you've a multi-site setup, so you must know the current URL being used
in order to send your emails in your mailers, simply create one instance of the
mailer per site and the instance should keep track of the URL.

OK, but the models want to use the mailers, they can't do
`UserMailer.sendEmail()` just like that, because they don't have the context of
the mailer's instance, unless you put the mailer in the `req` and give the model
the `req`, but we want to avoid that.

So we can give the DomainContainer instance the mailer instances through the
`modelExtras` property, as `modelExtras.mailers` or something like that.

The DomainContainer then will assign `modelExtras` to each model when it
instantiates it itself or when it's handling a model it is given, so that the
model has the contextualized mailers available to it.

The models can then use the mailers as
`this._modelExtras.mailers.user.sendEmail()` and the email will be sent with the
proper context of the current domain.
